#!/usr/bin/env python

usage = "plot_ensemble [--options] ensemble.txt"
description = "generate representations of the ensemble of points produced by localize"
author = "Reed Essick"

#-------------------------------------------------

import os

import numpy as np

import emcee ### for autocorrelation analysis

import simUtils as utils

import matplotlib
matplotlib.use('Agg')
from matplotlib import cm
from matplotlib import pyplot as plt
plt.rcParams['text.usetex'] = True

import corner

from optparse import OptionParser

#-------------------------------------------------

axpos = [0.03, 0.03, 0.94, 0.94]

deg2rad = np.pi/180
rad2deg = 1./deg2rad

#-------------------------------------------------

parser = OptionParser(usage=usage, description=description)

parser.add_option('-v', '--verbose', default=False, action='store_true')

parser.add_option('-o', '--output-dir', default='.', type='string')
parser.add_option('-t', '--tag', default='', type='string')

### reference parameters

parser.add_option('', '--theta', default=None, type='float',
    help='the injected parameter. Will be annotated on plots')
parser.add_option('', '--phi', default=None, type='float',
    help='the injected parameter. Will be annotated on plots')
parser.add_option('', '--psi', default=None, type='float',
    help='the injected parameter. Will be annotated on plots')
parser.add_option('', '--iota', default=None, type='float',
    help='the injected parameter. Will be annotated on plots')
parser.add_option('', '--distanceMpc', default=None, type='float',
    help='the injected parameter. Will be annotated on plots')
parser.add_option('', '--timeAtCoalescence', default=None, type='float',
    help='the injected parameter. Will be annotated on plots')

parser.add_option('', '--args-are-degrees', default=False, action='store_true')

### line-of-sight plots to make
parser.add_option('', '--line-of-sight', nargs=2, default=[], type='string', action='append',
    help='generate skymap scatters in this line of sight as well. \
Also, add dT marginal to corner plot. (eg: H L)')

### plotting options
parser.add_option('', '--color', default='k', type='string',
    help='color used for annotation in skymap scatter and truth annotations in corner')
parser.add_option('', '--alpha', default=1.0, type='float',
    help='alpha used for annotation in skymap scatter')

parser.add_option('', '--scatter-alpha', default=0.1, type='float',
    help='alpha used for markers in skymap scatter')
parser.add_option('', '--color-map', default="OrRd", type='string',
    help='used to color points in skymap scatter plot')

parser.add_option('', '--min-lnprob', default=None, type='float',
    help='the minimum lnprob plotted in skymap scatter')
parser.add_option('', '--max-lnprob', default=None, type='float',
    help='the maximum lnprob plotted in skymap scatter')

parser.add_option('', '--scatter-markersize', default=1, type='float',
    help='the markersize for skymap scatter plot')

opts, args = parser.parse_args()

assert len(args)==1, 'please supply exactly 1 input argument\n%s'%usage

if not os.path.exists(opts.output_dir):
    os.makedirs(opts.output_dir)

if opts.tag:
    opts.tag = "_"+opts.tag

if opts.args_are_degrees:
    if opts.theta!=None: 
        opts.theta *= deg2rad
    if opts.phi!=None: 
        opts.phi *= deg2rad
    if opts.psi!=None: 
        opts.psi *= deg2rad
    if opts.iota!=None: 
        opts.iota *= deg2rad

if opts.phi > np.pi:
    opts.phi -= 2*np.pi

#-------------------------------------------------

if opts.verbose:
    print( 'reading ensemble of samples from : '+args[0] )
samples = utils.load_ensemble( args[0] )
samples['phi'][samples['phi']>np.pi] -= 2*np.pi ### shift phi to match plotting range

# columns are :
#   k (walker number)
#   lnprob
#   theta
#   phi
#   psi
#   iota
#   distanceMpc
#   timeAtCoalescence

#-------------------------------------------------

### plot skymap first
if opts.verbose:
    print( '(scatter) plot skymap on mollweide projection' )

### color points by their lnprob
mappable = cm.ScalarMappable(
    norm=plt.Normalize(
        vmin=opts.min_lnprob if opts.min_lnprob!=None else np.min(samples['lnprob'][samples['lnprob']>-np.infty]),
        vmax=opts.max_lnprob if opts.max_lnprob!=None else np.max(samples['lnprob'][samples['lnprob']<np.infty]),
    ),
    cmap=plt.get_cmap(opts.color_map),
)
mappable.set_array(samples['lnprob'])

order = samples['lnprob'].argsort() ### smallest to largest
color = mappable.to_rgba(samples['lnprob'][order])

### iterate over line-of-sight frames
for tag, pole in [('', None)] + [('-'+''.join(los), utils.IFOs2pole(*los)) for los in opts.line_of_sight]:
    fig = plt.figure()
    ax = fig.add_axes(axpos, projection='mollweide')

    theta, phi = utils.ThetaPhi2LineOfSight( samples['theta'][order], samples['phi'][order], pole=pole )

    ax.scatter(
        phi, 
        0.5*np.pi - theta, ### plot declination, not theta
        color=color,
        alpha=opts.scatter_alpha,
        marker='o', 
        s=opts.scatter_markersize,
    )

    ### decorate
    cb = plt.colorbar(mappable, orientation='horizontal', shrink=0.8, fraction=0.15)
    cb.set_label('$\ln p(\\vec{\\theta}|\mathrm{data})$')

    ax.grid(True, which='both')
    if (opts.phi!=None) and (opts.theta!=None):
        theta, phi = utils.ThetaPhi2LineOfSight( opts.theta, opts.phi, pole=pole )
        ax.plot(phi, 0.5*np.pi-theta, marker='x', markersize=10, color=opts.color, alpha=opts.alpha )

    figname = "%s/ensemble-skymap%s%s.png"%(opts.output_dir, tag, opts.tag)
    if opts.verbose:
        print( '    saving : '+figname )
    fig.savefig(figname)
    plt.close(figname)

#------------------------

### corner plot of all extrinsic parameters
if opts.verbose:
    print( 'corner plot' )

# set up data and labels
data = [
    samples['theta']*rad2deg,
    samples['phi']*rad2deg,
    samples['psi']*rad2deg,
    samples['iota']*rad2deg,
    samples['distanceMpc'],
    samples['timeAtCoalescence'],
]

labels = [
    r"$\theta$ [$^\circ$]", 
    r"$\phi$ [$^\circ$]", 
    r"$\psi$ [$^\circ$]", 
    r"$\iota$ [$^\circ$]", 
    '$D$ [Mpc]', 
    '$t_0$ [sec]',
]

truths = [
    opts.theta*rad2deg if opts.theta!=None else None,
    opts.phi*rad2deg if opts.phi!=None else None,
    opts.psi*rad2deg if opts.psi!=None else None,
    opts.iota*rad2deg if opts.iota!=None else None,
    opts.distanceMpc,
    opts.timeAtCoalescence,
]

sinTheta = np.sin(samples['theta'])
cosTheta = np.cos(samples['theta'])
sinPhi = np.sin(samples['phi'])
cosPhi = np.cos(samples['phi'])
N = -np.array([sinTheta*cosPhi, sinTheta*sinPhi, cosTheta]) ### wave's direction of propagation

for ifo1, ifo2 in opts.line_of_sight: ### add in data for line-of-sight time-delay marginals
    det1 = utils.known_detectors[ifo1]
    det2 = utils.known_detectors[ifo2]

    dt = np.sum(np.outer(det1.r-det2.r,np.ones_like(sinTheta))*N, axis=0)*1e3 ### plot in ms

    data.append( dt )
    labels.append( '$\Delta t_{%s%s}$ [ms]'%(ifo1, ifo2) )
    if opts.theta and opts.phi:
        truths.append( np.sum((det1.r-det2.r)*(-np.array([np.sin(opts.theta)*np.cos(opts.phi), np.sin(opts.theta)*np.sin(opts.phi), np.cos(opts.theta)])))*1e3 )
    else:
        truths.append( None )

# delegate to generate figure
fig = corner.corner(
    data, 
    labels=labels,
    truths=truths,
    truth_color=opts.color,
    quantiles=[0.10, 0.50, 0.90],
    show_titles=True, 
    title_kwargs={"fontsize": 12},
)

figname = "%s/ensemble-corner%s.png"%(opts.output_dir, opts.tag)
if opts.verbose:
    print( '    saving : '+figname )
fig.savefig(figname)
plt.close(fig)

#------------------------

### autocorrelation analysis
if opts.verbose:
    print( 'autocorrelation analysis' )

raise NotImplementedError, '''\
autocorrelation analysis
    - emcee.autocorr.integrated_time
    - emcee.autocorr.function'''
